<?php
/*
Plugin Name: WordPress Malware Scanner (Improved)
Description: A plugin to scan and clean WordPress installations for malware with improved safety measures.
Author: RiotRequest (Updated)
Version: 2.0
*/

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

/**
 * Initialize the WordPress Filesystem API.
 */
function wms_initialize_filesystem() {
    if ( ! function_exists( 'WP_Filesystem' ) ) {
        require_once ABSPATH . 'wp-admin/includes/file.php';
    }
    global $wp_filesystem;
    if ( empty( $wp_filesystem ) ) {
        WP_Filesystem();
    }
}
add_action( 'admin_init', 'wms_initialize_filesystem' );

/**
 * Add admin menu.
 */
function wms_scanner_menu() {
    add_menu_page(
        'Malware Scanner',
        'Malware Scanner',
        'manage_options',
        'malware-scanner',
        'wms_scanner_admin_page',
        'dashicons-shield',
        100
    );
}
add_action( 'admin_menu', 'wms_scanner_menu' );

/**
 * Admin page content.
 */
function wms_scanner_admin_page() {
    ?>
    <div class="wrap">
        <h1>Malware Scanner</h1>
        <p>
            This tool can scan your WordPress installation for suspicious code.
            <strong>Dry Run</strong> will only report potential issues.
            <strong>Run Scan</strong> will automatically attempt to clean the issues after your confirmation.
        </p>
        <button id="dry-run-malware" class="button">Dry Run Scan</button>
        <button id="scan-malware" class="button button-primary" disabled>Run Clean Scan</button>
        <div id="scan-results" style="margin-top:20px;"></div>
    </div>
    <script type="text/javascript">
        jQuery(document).ready(function($) {
            // Dry Run scan
            $('#dry-run-malware').on('click', function() {
                $('#scan-results').html('Scanning... Please wait.');
                $.post(ajaxurl, {
                    action: 'wms_scan_wordpress',
                    mode: 'dry_run'
                }, function(response) {
                    $('#scan-results').html(response);
                    // Enable the cleaning button if potential malware was found
                    if (response.indexOf('Infected files found:') !== -1) {
                        $('#scan-malware').prop('disabled', false);
                    } else {
                        $('#scan-malware').prop('disabled', true);
                    }
                });
            });

            // Clean Scan (requires confirmation)
            $('#scan-malware').on('click', function() {
                if ( confirm('Are you sure you want to clean the detected malware? A backup will be created for each file modified.') ) {
                    $('#scan-results').html('Cleaning scan in progress... Please wait.');
                    $.post(ajaxurl, {
                        action: 'wms_scan_wordpress',
                        mode: 'scan'
                    }, function(response) {
                        $('#scan-results').html(response);
                        // Disable the cleaning button after a cleaning operation.
                        $('#scan-malware').prop('disabled', true);
                    });
                }
            });
        });
    </script>
    <?php
}

/**
 * AJAX handler for scanning and cleaning.
 */
function wms_scan_wordpress_ajax() {
    if ( ! current_user_can( 'manage_options' ) ) {
        wp_die( 'Unauthorized user' );
    }

    $mode = isset( $_POST['mode'] ) ? sanitize_text_field( $_POST['mode'] ) : 'dry_run';
    $result = wms_scan_and_clean_wordpress(ABSPATH, $mode);
    echo wp_kses_post( nl2br( $result ) );
    wp_die();
}
add_action( 'wp_ajax_wms_scan_wordpress', 'wms_scan_wordpress_ajax' );

/**
 * Main scanning and cleaning function.
 *
 * @param string $directory Directory to scan.
 * @param string $mode 'dry_run' for reporting or 'scan' for cleaning.
 * @return string Report of scan results.
 */
function wms_scan_and_clean_wordpress( $directory, $mode = 'dry_run' ) {
    global $wp_filesystem;
    wms_initialize_filesystem();

    // Define file extensions to scan.
    $scan_extensions = array( 'php', 'phtml', 'php3', 'php4', 'php5', 'php7', 'phps', 'js', 'html', 'htm', 'htaccess' );

    // Define suspicious strings to look for. These are more specific indicators.
    $malware_signatures = array(
        'base64_decode',
        'eval(',
        'gzinflate',
        'str_rot13',
        'eval_base64_decode',
        'exec_shell',
        'shell_exec',
        'popen',
        'proc_open',
        'system',
        'curl_exec',
        'curl'
    );

    // Directories to exclude from scanning.
    $excluded_dirs = array(
        realpath( ABSPATH . 'wp-content/uploads' ),
        realpath( ABSPATH . 'wp-content/cache' ),
    );

    $infected_files = array();
    $has_malware    = false;
    $report         = '';

    // Set up a Recursive Directory Iterator.
    try {
        $dir_iterator = new RecursiveDirectoryIterator( $directory, RecursiveDirectoryIterator::SKIP_DOTS );
    } catch ( Exception $e ) {
        return "Error accessing directory: " . esc_html( $e->getMessage() );
    }
    $iterator = new RecursiveIteratorIterator( $dir_iterator );

    foreach ( $iterator as $file_obj ) {
        $file_path = $file_obj->getPathname();

        // Skip excluded directories.
        $skip = false;
        foreach ( $excluded_dirs as $excluded ) {
            if ( strpos( realpath( $file_path ), $excluded ) === 0 ) {
                $skip = true;
                break;
            }
        }
        if ( $skip ) {
            continue;
        }

        // Only process files with one of the defined extensions.
        $ext = strtolower( pathinfo( $file_path, PATHINFO_EXTENSION ) );
        if ( ! in_array( $ext, $scan_extensions, true ) && ! in_array( basename( $file_path ), $scan_extensions, true ) ) {
            continue;
        }

        // Read file contents using the WP Filesystem API.
        $file_contents = $wp_filesystem->get_contents( $file_path );
        if ( $file_contents === false ) {
            $infected_files[] = "Could not read file: $file_path";
            continue;
        }

        $clean = true;
        // Check for each malware signature.
        foreach ( $malware_signatures as $signature ) {
            if ( stripos( $file_contents, $signature ) !== false ) {
                $clean = false;
                break;
            }
        }

        // If a suspicious pattern is found, mark the file as infected.
        if ( ! $clean ) {
            $has_malware   = true;
            $infected_files[] = "Infected file found: $file_path";

            // If mode is 'scan', attempt to clean the file.
            if ( 'scan' === $mode ) {
                // Create a unique backup filename.
                $backup_file = $file_path . '.' . time() . '.bak';
                if ( ! $wp_filesystem->copy( $file_path, $backup_file, true ) ) {
                    $infected_files[] = "Failed to create backup for: $file_path";
                    continue;
                }

                // Attempt to remove suspicious code patterns.
                $cleaned_contents = $file_contents;
                // Remove base64_decode() calls.
                $cleaned_contents = preg_replace( "/base64_decode\s*\((.*?)\)/i", "", $cleaned_contents );
                // Remove each signature string.
                foreach ( $malware_signatures as $signature ) {
                    $cleaned_contents = str_ireplace( $signature, '', $cleaned_contents );
                }

                // Write the cleaned contents back to the file.
                if ( false === $wp_filesystem->put_contents( $file_path, $cleaned_contents, FS_CHMOD_FILE ) ) {
                    $infected_files[] = "Failed to write cleaned contents to: $file_path";
                    continue;
                }
                $infected_files[] = "Cleaned malware from: $file_path (backup saved as $backup_file)";
            }
        }
    }

    // Build the result report.
    if ( ! $has_malware ) {
        $report .= "No infected files were found in the installation: " . esc_html( $directory ) . "\n";
    } else {
        $report .= "Infected files found:\n";
        foreach ( $infected_files as $entry ) {
            $report .= $entry . "\n";
        }
    }

    return $report;
}
?>
